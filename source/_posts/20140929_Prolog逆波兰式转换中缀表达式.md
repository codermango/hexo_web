title: Prolog逆波兰式转换成中缀表达式
date: 2014-09-29
tags: [Prolog, 逆波兰式]
categories: Prolog

---

逆波兰表达式，是波兰数学家1920年引入的数学表达式方法。在逆波兰表示法中，所有的操作符都置于操作数后面，也称为后缀表达法。我们通常的数学表达式是中缀表达式。举例说明，我们平常的表达式`3+2`，用逆波兰表达式就为`32+`。逆波兰表示法不需要括号来标示操作符的优先级。有人会说为什么要用如此不直观的方法表示，其实直观不直观是对人类来说的，我们认为的很直观的中缀表达法对计算机来说却是一种非常复杂的数据结构，而后缀表示法却很易于计算机处理，至于如何易于处理不是本文的重点。

很多数据结构和算法的书籍都会有后缀表示法向中缀表示法转换的算法，最近由于课程Project，需要用Prolog实现这个功能，以下我们就来分析下如何把逆波兰式转换成中缀表达式。

首先先把程序给出：  
````Prolog
rpn2exp([X], [], X).
rpn2exp(Stack, [Head|Tail], Res) :-
	integer(Head),
	rpn2exp([Head|Stack], Tail, Res).
rpn2exp([X,Y|Others], [Head|Tail], Res) :-
	operator(Head),
	doop(Head, Y, X, X1),
	rpn2exp([X1|Others], Tail, Res).
````

这里我们来举例说明，把`31+2*`转化为`(3+1)*2`。那么调用函数就为：  
`rpn2exp([], [3, 1, +, 2, *], Res)`

`[]`定义一个栈，把第二个参数（逆波兰式）一个个压入栈中。第一次调用的时候，匹配到`rpn2exp(Stack, [Head|Tail], Res)`，`Prolog`开始匹配，满足`integer(3)`和`rpn2exp([Head|Stack], Tail, Res)`，递归一次，Stack中就变成了[3]。第二次再递归一次，同样匹配成功，Stack变成[1, 3]，第三次的时候，Tail里是[+, 2, *]，`integer(Head)`匹配不成功，所以它会匹配`rpn2exp([X,Y|Others], [Head|Tail], Res)`。 这里operator和doop的具体实现不用理会，先知道operator在这里就是说Head是操作符就返回真，doop的作用是把这一部分变成中缀表达式`（X1=3+1）`。然后把之前运算后的X，Y出栈，结果X1入栈，则此时栈里面的情况就是`[3+1]`。

这样不断的循环，最后栈中只会剩下一个数字，这个数字就是最后的结果，最后一次会匹配`rpn2exp([X], [], X)`。

这个例子入栈出栈的情况如下:
````
	[3]
	[3, 1]
	[3, 1, +]   -> 4
	[4]
	[4, 2]
	[4, 2, *]   -> 8
	[8]
````






